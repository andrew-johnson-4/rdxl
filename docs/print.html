<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> HTML Markup</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Rust Code</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Markup Reference</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Expression Reference</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Statement Reference</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Breaking Spaces</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> xrender</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> xtype</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Rdxl is a set of macros for generating xhtml from Rust. By using rdxl
it is possible to intermix xhtml and Rust code to generate interactive documents.</p>
<p>In this book we will document the exact grammar of each rdxl macro and
provide many motivating examples and several cheat sheets.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
  println!(&quot;{}&quot;,rdxl::xhtml!(
    &lt;p&gt;This copy, version {{rdxl::version}}, is the latest copy of this document&lt;/p&gt;
    &lt;p&gt;We hope that this will satisfy all your web templating needs&lt;/p&gt;
  ));
}
</code></pre></pre>
<h1><a class="header" href="#html-markup" id="html-markup">HTML Markup</a></h1>
<p>When generating markup, the most common macro to be used is xhtml!. This macro
takes mixed markup and rust code to output markup formatted as a String.</p>
<p>Inside xhtml! there are several possible types of markup that can be sent to
the formatter:</p>
<ol>
<li>XHTML Tags</li>
<li>Unquoted Text Data</li>
<li>Quoted Text Data</li>
</ol>
<p>To generate XHTML Tags, place the tags in angle brackets like normal markup. The
tags can be self-closing or contain inner HTML.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
  println!(&quot;{}&quot;,rdxl::xhtml!(
    &lt;br/&gt;
  ));
}
</code></pre></pre>
<p>To generate Unquoted Text Data it is usually sufficient to place the text
directly in the markup. Note that macros are lexed as Rust code before being
sent to the macro procedure. This means that not all XHTML can be placed directly
inline.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
  println!(&quot;{}&quot;,rdxl::xhtml!(
    &lt;p&gt;This paragraph is formatted normally. The breaking spaces are recognized
       as part of the macro rules.&lt;/p&gt;
  ));
}
</code></pre></pre>
<p>For Text Data that does not work well with the Rust lexer, the text may be placed
inside a rust quoted string literal. This string will be placed directly into the
formatted output. It should be noted that raw strings are very a good way to fit
even more text data into one quote without the need for escape characters.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
  println!(&quot;{}&quot;,rdxl::xhtml!(
    r#&quot;((((( the lexer expects closing braces, brackets, and parentheses [[[[
       but what do we care. {{&quot;#
  ));
}
</code></pre></pre>
<h1><a class="header" href="#rust-code" id="rust-code">Rust Code</a></h1>
<p>Rust code greatly enhances the generative capabilities of the Rdxl macro rules.
Most rust expressions and statements may be placed inside of Rdxl markup and
generate code nearly identical to what is stated. This is very helpful not
only for creating new powerful abstractions, but also for fixing bugs: error
messages for syntax or type errors are correctly tracked and blamed with the
same helpful error formatting that Rust is so well known for.</p>
<p>In Rdxl, Rust code is divided into two kinds of syntax expressions: Rust statements
and Rust expressions. The difference between a statement or expression is always
determined by syntax rather than inference. Expressions always emit a value that
implements the Display trait as the return value of the expression. Statements
may emit data directly to the string buffer but never as the return value of the
statement.</p>
<p>Both expressions and statements are surrounded by double braces to signify that
they should be interpreted as Rust code rather than xhtml.</p>
<p>A simple example of a rust expression is a variable interpolated into the markup:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   let x = 5;
   println!(&quot;{}&quot;, rdxl::xhtml!(
      These strings are literals, but {{x}} is a variable.
   ));
}
</code></pre></pre>
<p>For a complete reference of all expressions, see <a href="./chapter_5.html">Chapter 5: Expression Reference</a>.</p>
<p>A simple statement would be a for loop:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ for x in 0..10 {{
         These strings are literals, but {{x}} is a variable.
      }} }}
   ));
<span class="boring">}
</span></code></pre></pre>
<p>For a complete reference of all statements, see <a href="./chapter_6.html">Chapter 6: Statement Reference</a>.</p>
<h1><a class="header" href="#markup-reference" id="markup-reference">Markup Reference</a></h1>
<p>All html tags may be used directly in the body of the macro invocation.
Most tag attributes may be used normally as well. Some tag attribute
names, for example those with dashes in them, confuse the Rust
lexer and therefore should be quoted. All strings are valid attribute
names as long as they are quoted as a string literal.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   println!(&quot;{}&quot;, rdxl::xhtml!(
      &lt;a href=&quot;/this_is_ok&quot; &quot;this-must-be-quoted&quot;=&quot;abcd&quot;&gt;body of link&lt;/a&gt;
   ));
}
</code></pre></pre>
<p>Rust expressions may be interpolated as attribute values. To insert a
Rust expression in attribute position, use the double braces format.
When rust expressions are used as attributes, the string value is
quoted and escape characters are inserted in place of double quotes
etc.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   let a_class = &quot;my_class&quot;;
   let a_style = &quot;position:absolute; top:0; left:0;&quot;;
   println!(&quot;{}&quot;, rdxl::xhtml!(
      &lt;div class={{a_class}} style={{a_style}}&gt;inner html&lt;/div&gt;
   ));
}
</code></pre></pre>
<h1><a class="header" href="#expression-reference" id="expression-reference">Expression Reference</a></h1>
<p>All interpolated Rust code is interpreted as an expression
provided that</p>
<ol>
<li>The snippet does not start with a reserved statement keyword</li>
<li>The snippet does not end with a semicolon</li>
</ol>
<p>The statement keywords are: if, let, for, while, and loop.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   let a_flag = true;
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ if a_flag {{ this is a statement }} }}
      {{ (if a_flag { &quot;this is&quot; } else { &quot;an expression&quot; }) }}
   ));
}
</code></pre></pre>
<p>Aside from these reservations, all Rust code may be used as
expressions as long as they return a value that implements the
Display trait.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   println!(&quot;{}&quot;, rdxl::xhtml!(
     {{ &quot;ab&quot; }}
     {{ 'c' }}
     {{ format!(&quot;{} {}&quot;, 2, 3) }}
     {{ true }}
   ));
}
</code></pre></pre>
<h1><a class="header" href="#statement-reference" id="statement-reference">Statement Reference</a></h1>
<p>The statement forms are: if, let, for, while, and loop. Also, if
an expression ends with a semicolon its value will be discarded.</p>
<h2><a class="header" href="#semicolon" id="semicolon">Semicolon</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   let mux x = 3;
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ x += 2; }}
   ));
}
</code></pre></pre>
<h2><a class="header" href="#if" id="if">If</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   let x = 3;
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ if x&lt;2 {{
         Case 1
      }} else if x&lt;5 {{
         Case 2
      }} else {{
         Case 3
      }}
   ));
}
</code></pre></pre>
<h2><a class="header" href="#let" id="let">Let</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ let mut x = 5; }}
      {{ x }}
      {{ x += 2; }}
      {{ x }}
   ));
}
</code></pre></pre>
<h2><a class="header" href="#for" id="for">For</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ for x in 0..10 {{
         {{x}}
      }} }}
   ));
}
</code></pre></pre>
<h2><a class="header" href="#while" id="while">While</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   let mut x = 3;
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ while x&gt;0 {{
         {{ x }}
         {{ x -= 1; }}
      }} }}
   ));
}
</code></pre></pre>
<h2><a class="header" href="#loop" id="loop">Loop</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rdxl;

fn main() {
   println!(&quot;{}&quot;, rdxl::xhtml!(
      {{ loop {{
         &lt;p&gt;inside loop&lt;/p&gt;
         {{ break; }}
      }} }}
   ));
}
</code></pre></pre>
<h1><a class="header" href="#breaking-spaces" id="breaking-spaces">Breaking Spaces</a></h1>
<p>Rdxl macros try to guess when inserting breaking spaces
would be appropriate. This is quite difficult and 
absurd when it comes to statements. For that reason,
most statements just emit breaking spaces regardless
of whether there are any spaces in the input.</p>
<p>The implementation of breaking space detection is
reliant on the <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html">span location</a>
information provided to procedural macros. This
feature has been under ongoing development, so
there may be quirks from Rust version to version.</p>
<h1><a class="header" href="#xrender" id="xrender">xrender</a></h1>
<p>The xrender! macro defines a Display trait for a
type. The type is supplied as the first argument,
and the rest of the macro defines the XHTML that
is to be formatted as output.</p>
<p>All fields of the type can be accessed through the
<em>self</em> value which is defined over the body of
the macro invocation.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate rdxl;

xrender!(MyList, &lt;ul&gt;
  &lt;li&gt;{{ self.my_string }}&lt;/li&gt;
  &lt;li&gt;{{ self.my_int }}&lt;/li&gt;
  {{ for i in self.children.iter() {{
    {{ if let MyListChildren::MyItem(my_item) = i {{
      &lt;li&gt;MyItem: {{ my_item.my_bool }}&lt;/li&gt;
    }} else if let MyListChildren::MyOtherItem(my_other_item) = i {{
      &lt;li&gt;MyOtherItem: {{ my_other_item.my_char }}&lt;/li&gt;
    }} }}
  }} }}
&lt;/ul&gt;);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#xtype" id="xtype">xtype</a></h1>
<p>The xtype! macro defines an XML-like struct. An XML-like struct
has zero or more attributes, possibly having default values, and
zero or more possible children types.</p>
<p>Attributes that do not supply a default value must have a type
which implements the std::default::Default trait. This is
an implementation quirk, so it is notable, although undesirable.</p>
<p>Children can have any type, which may be defined inline as another
tag, or reference an existing type. A boxed Display type is
available by using the ? tag, which is a handy way to include
miscellaneous content which does not require special rendering
logic.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate rdxl;

xtype!(&lt;!MyTag a:u64={{32}} b:String&gt;
  &lt;?&gt;
&lt;/MyTag&gt;);
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
